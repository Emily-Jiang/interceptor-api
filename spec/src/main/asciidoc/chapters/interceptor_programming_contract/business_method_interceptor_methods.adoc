////
*******************************************************************
* Copyright (c) 2019 Eclipse Foundation
*
* This specification document is made available under the terms
* of the Eclipse Foundation Specification License v1.0, which is
* available at https://www.eclipse.org/legal/efsl.php.
*******************************************************************
////

[[business_method_interceptor_methods]]
=== Business Method Interceptor Methods

Interceptor methods that interpose on
business method invocations are denoted by the _AroundInvoke_
annotation.

Around-invoke methods may be declared in
interceptor classes, in the superclasses of interceptor classes, in the
target class, and/or in superclasses of the target class. However, only
one around-invoke method may be declared in a given class.

Around-invoke methods can have _public_ ,
_private_ , _protected_ , or _package_ level access. An around-invoke
method must not be declared as _abstract, final or static_ .

Around-invoke methods have the following
signature:

 Object <METHOD>(InvocationContext)

_Note: An around-invoke interceptor method may
be declared to throw any checked exceptions that the associated target
method allows within its throws clause. It may be declared to throw the
java.lang.Exception, for example, if it interposes on several methods
that can throw unrelated checked exceptions._

An around-invoke method can invoke any
component or resource that the method it is intercepting can invoke.

In general, an around-invoke method
invocation occurs within the same transaction and security context as
the method on which it is interposing. However, note that the
transaction context may be changed by transactional interceptor methods
in the invocation chain, such as those defined by the _Jakarta Transaction
API_ specification <<bib7>> .

The following example defines
_MonitoringInterceptor_, which is used to interpose on _ShoppingCart_
business methods:

[source, java]
----
@Inherited
@InterceptorBinding
@Target({TYPE, METHOD})
@Retention(RUNTIME)
public @interface Monitored {}

@Monitored @Interceptor
public class MonitoringInterceptor {
    @AroundInvoke
    public Object monitorInvocation(InvocationContext ctx) {
        //... log invocation data ...
        return ctx.proceed();
    }
}

@Monitored
public class ShoppingCart {
    public void placeOrder(Order o) {
        ...
    }
}
----
